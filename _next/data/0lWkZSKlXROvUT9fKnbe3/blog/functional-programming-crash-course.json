{"pageProps":{"frontmatter":{"title":"[unfinished] Refactoring to Functional paradigm","date":"2022/02/02","excerpt":"Dotchaining the non-dotchainable in Node JS","tags":""},"slug":"functional-programming-crash-course","content":"### What we already know about developing applications\n\nwe start with names, key-value pairs, ifs and elses, iteration and procedures.\non top of all this we have atomic data types in every single programming languages such as strings, numbers and booleans.\nwe can go even higher than that to reach arrays, hashes and namespaces.\nobject oriented programming brings other abstractions such as classes, objects with methods and inheritance.\nA mixture of all these entities make up our _programs_\n\n### A reason to refactor\n\nfunctional programming is refactoring what you already know about wiritng applications\nAt the start applications are written neatly but as the time goes on and we keep adding features and dependancies to our apps, it becomes a mess\n\n### Mathematicions have the same problems as we do\n\nIn my opinion, computer science is a subset of mathematics. They faced the very problems we have with writing our applications and came up with _principia mathematica_ to try to explain maths in atomic levels of abstraction\n\nIn mathematics, a function is a relation between two sets, a mapping from one to another.\n\nwhat we do is not the same as functions, we return numbers, or void or IO or database or HTTP request\n\nwhat if applied some rules to our programming to make it look like maths?\n\n-   Look at inoput and parameteres, generate output\n-   no side effects\n\nin hope of making programs easier to understand and easier to maintain\nfx wont affect x\n\nmake datastructures immutable\ndont change things\nhow can we be productive? make a copy of any ds you want to mutate.\nthere's a problem. a lot of copies. what if you have a milion element array?\n\n### lets start with a clean sheet of paper\n\n### side effects\n\ncustomers and business care about the side effecst! actyally desired effects!\nhow to change outside world with functional limitations?\nthere should a some kind of a queue that has messy appearance that our functions inqueue stuff in it and some parts of our code grabas stuff from it and executes it\n\n### Functional refactoring in action\n\nHere's what we want to achieve. we first need to read the text content of a `.svg` file, then we need to pipe the content through a package called `svgo`. It optimizes SVG string and removes unneeded content without affecting the actual vectors. Then we need to make a `.vue` single file component and write the content we have in it.\n\n```javascript\n// optimizer.js\nconst fs = require(\"fs\");\nconst { optimize } = require(\"svgo\");\n\nconst optimizer = (arg) => ({\n    import: () => optimizer(readFiles(arg)),\n    optimize: () => optimizer(optimizeItems(arg)),\n    export: () => writeComponents(arg),\n});\n\nconst readFiles = (paths) =>\n    paths.map((filePath) => ({\n        path: filePath,\n        content: fs.readFileSync(filePath, \"utf8\"),\n    }));\n\nconst optimizeItems = (contents) => contents.map(optimize);\n\nconst writeComponents = (items) => {\n    items.forEach((item) =>\n        fs.writeFileSync(component.path, component.content)\n    );\n}\n\noptimizer([\"foo.svg\", \"bar.svg\"]).import().optimize().export();\n```\n\nnotice we are only declaring seperated functions with predictible actions without any mutiation to any variable\nthree main functions to do certain tasks. then aggregate these functions in `optimizer` factory function to be able to do dot chaining with the results\n\nyou can write individual tests for each function and increse the coverage\n"},"__N_SSG":true}