<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>[unfinished] Refactoring to Functional paradigm</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/7ddbd52f8ac0d789.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7ddbd52f8ac0d789.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d7932dc5e3ad1682.js" defer=""></script><script src="/_next/static/chunks/649-b044e215cc172295.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-152ade585c64ad99.js" defer=""></script><script src="/_next/static/0lWkZSKlXROvUT9fKnbe3/_buildManifest.js" defer=""></script><script src="/_next/static/0lWkZSKlXROvUT9fKnbe3/_ssgManifest.js" defer=""></script><script src="/_next/static/0lWkZSKlXROvUT9fKnbe3/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="mb-8 bg-dark-blog"><div class="container flex items-center justify-between py-8 mx-auto lg:px-32"><span class="text-3xl font-lobster cursor-pointer text-secondary-blog" href="/">Mehdi&#x27;s Engineering Blog</span><a href="https://www.github.com/mhdi-kr" referrerPolicy="no-referrer"><svg class="fill-neutral-500 hover:fill-neutral-300 transition-colors cursor-pointer" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"></path></svg></a></div></header><section class="container flex items-start lg:px-32 mx-auto"><main class="w-2/3"><article><div class="mb-4 pt-8"><h2 class="lg:text-2xl text-base mb-2">[unfinished] Refactoring to Functional paradigm</h2><div class="text-neutral-400 text-xs lg:text-base">Posted on <!-- -->2022/02/02</div></div><div class="post-body"><div class="subpixel-antialiased lg:text-lg text-sm tracking-normal"><h3>What we already know about developing applications</h3>
<p>we start with names, key-value pairs, ifs and elses, iteration and procedures.
on top of all this we have atomic data types in every single programming languages such as strings, numbers and booleans.
we can go even higher than that to reach arrays, hashes and namespaces.
object oriented programming brings other abstractions such as classes, objects with methods and inheritance.
A mixture of all these entities make up our <em>programs</em></p>
<h3>A reason to refactor</h3>
<p>functional programming is refactoring what you already know about wiritng applications
At the start applications are written neatly but as the time goes on and we keep adding features and dependancies to our apps, it becomes a mess</p>
<h3>Mathematicions have the same problems as we do</h3>
<p>In my opinion, computer science is a subset of mathematics. They faced the very problems we have with writing our applications and came up with <em>principia mathematica</em> to try to explain maths in atomic levels of abstraction</p>
<p>In mathematics, a function is a relation between two sets, a mapping from one to another.</p>
<p>what we do is not the same as functions, we return numbers, or void or IO or database or HTTP request</p>
<p>what if applied some rules to our programming to make it look like maths?</p>
<ul>
<li>Look at inoput and parameteres, generate output</li>
<li>no side effects</li>
</ul>
<p>in hope of making programs easier to understand and easier to maintain
fx wont affect x</p>
<p>make datastructures immutable
dont change things
how can we be productive? make a copy of any ds you want to mutate.
there's a problem. a lot of copies. what if you have a milion element array?</p>
<h3>lets start with a clean sheet of paper</h3>
<h3>side effects</h3>
<p>customers and business care about the side effecst! actyally desired effects!
how to change outside world with functional limitations?
there should a some kind of a queue that has messy appearance that our functions inqueue stuff in it and some parts of our code grabas stuff from it and executes it</p>
<h3>Functional refactoring in action</h3>
<p>Here's what we want to achieve. we first need to read the text content of a <code>.svg</code> file, then we need to pipe the content through a package called <code>svgo</code>. It optimizes SVG string and removes unneeded content without affecting the actual vectors. Then we need to make a <code>.vue</code> single file component and write the content we have in it.</p>
<pre><code class="language-javascript">// optimizer.js
const fs = require(&quot;fs&quot;);
const { optimize } = require(&quot;svgo&quot;);

const optimizer = (arg) =&gt; ({
    import: () =&gt; optimizer(readFiles(arg)),
    optimize: () =&gt; optimizer(optimizeItems(arg)),
    export: () =&gt; writeComponents(arg),
});

const readFiles = (paths) =&gt;
    paths.map((filePath) =&gt; ({
        path: filePath,
        content: fs.readFileSync(filePath, &quot;utf8&quot;),
    }));

const optimizeItems = (contents) =&gt; contents.map(optimize);

const writeComponents = (items) =&gt; {
    items.forEach((item) =&gt;
        fs.writeFileSync(component.path, component.content)
    );
}

optimizer([&quot;foo.svg&quot;, &quot;bar.svg&quot;]).import().optimize().export();
</code></pre>
<p>notice we are only declaring seperated functions with predictible actions without any mutiation to any variable
three main functions to do certain tasks. then aggregate these functions in <code>optimizer</code> factory function to be able to do dot chaining with the results</p>
<p>you can write individual tests for each function and increse the coverage</p>
</div></div><hr class="my-4"/><button><a href="" class="text-gray-400"><span class="mr-4">‚Üê</span><span>Back to the main page</span></a></button><div id="inject-comments-for-uterances" class="mb-8"></div></article></main><aside class="p-8 w-1/3 text-sm sticky top-0"><div class="mb-4"><h2 class="font-medium mb-2 text-gray-600">5 Recent posts</h2><ul class="text-gray-500"><li>Developer&#x27;s Procrastination</li><li>Memory management in Arduino</li><li>Refactoring to Functional paradigm</li><li>Frontend Development Skilltree</li><li>Memory management in Arduino</li></ul></div><div class="mb-4"><h2 class="font-medium mb-2 text-gray-600">Tags</h2><ul class="text-gray-500 flex flex-wrap"><li class="mr-1 mb-1 text-xs bg-gray-100 p-1 rounded cursor-pointer">tutorial</li><li class="mr-1 mb-1 text-xs bg-gray-100 p-1 rounded cursor-pointer">frontend</li><li class="mr-1 mb-1 text-xs bg-gray-100 p-1 rounded cursor-pointer">embeded</li><li class="mr-1 mb-1 text-xs bg-gray-100 p-1 rounded cursor-pointer">backend</li><li class="mr-1 mb-1 text-xs bg-gray-100 p-1 rounded cursor-pointer">devops</li><li class="mr-1 mb-1 text-xs bg-gray-100 p-1 rounded cursor-pointer">test</li><li class="mr-1 mb-1 text-xs bg-gray-100 p-1 rounded cursor-pointer">life</li></ul></div></aside></section><footer class="bg-dark-blog text-center p-2"><time class="text-white text-xs">2019 - <!-- -->2022</time></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"[unfinished] Refactoring to Functional paradigm","date":"2022/02/02","excerpt":"Dotchaining the non-dotchainable in Node JS","tags":""},"slug":"functional-programming-crash-course","content":"### What we already know about developing applications\n\nwe start with names, key-value pairs, ifs and elses, iteration and procedures.\non top of all this we have atomic data types in every single programming languages such as strings, numbers and booleans.\nwe can go even higher than that to reach arrays, hashes and namespaces.\nobject oriented programming brings other abstractions such as classes, objects with methods and inheritance.\nA mixture of all these entities make up our _programs_\n\n### A reason to refactor\n\nfunctional programming is refactoring what you already know about wiritng applications\nAt the start applications are written neatly but as the time goes on and we keep adding features and dependancies to our apps, it becomes a mess\n\n### Mathematicions have the same problems as we do\n\nIn my opinion, computer science is a subset of mathematics. They faced the very problems we have with writing our applications and came up with _principia mathematica_ to try to explain maths in atomic levels of abstraction\n\nIn mathematics, a function is a relation between two sets, a mapping from one to another.\n\nwhat we do is not the same as functions, we return numbers, or void or IO or database or HTTP request\n\nwhat if applied some rules to our programming to make it look like maths?\n\n-   Look at inoput and parameteres, generate output\n-   no side effects\n\nin hope of making programs easier to understand and easier to maintain\nfx wont affect x\n\nmake datastructures immutable\ndont change things\nhow can we be productive? make a copy of any ds you want to mutate.\nthere's a problem. a lot of copies. what if you have a milion element array?\n\n### lets start with a clean sheet of paper\n\n### side effects\n\ncustomers and business care about the side effecst! actyally desired effects!\nhow to change outside world with functional limitations?\nthere should a some kind of a queue that has messy appearance that our functions inqueue stuff in it and some parts of our code grabas stuff from it and executes it\n\n### Functional refactoring in action\n\nHere's what we want to achieve. we first need to read the text content of a `.svg` file, then we need to pipe the content through a package called `svgo`. It optimizes SVG string and removes unneeded content without affecting the actual vectors. Then we need to make a `.vue` single file component and write the content we have in it.\n\n```javascript\n// optimizer.js\nconst fs = require(\"fs\");\nconst { optimize } = require(\"svgo\");\n\nconst optimizer = (arg) =\u003e ({\n    import: () =\u003e optimizer(readFiles(arg)),\n    optimize: () =\u003e optimizer(optimizeItems(arg)),\n    export: () =\u003e writeComponents(arg),\n});\n\nconst readFiles = (paths) =\u003e\n    paths.map((filePath) =\u003e ({\n        path: filePath,\n        content: fs.readFileSync(filePath, \"utf8\"),\n    }));\n\nconst optimizeItems = (contents) =\u003e contents.map(optimize);\n\nconst writeComponents = (items) =\u003e {\n    items.forEach((item) =\u003e\n        fs.writeFileSync(component.path, component.content)\n    );\n}\n\noptimizer([\"foo.svg\", \"bar.svg\"]).import().optimize().export();\n```\n\nnotice we are only declaring seperated functions with predictible actions without any mutiation to any variable\nthree main functions to do certain tasks. then aggregate these functions in `optimizer` factory function to be able to do dot chaining with the results\n\nyou can write individual tests for each function and increse the coverage\n"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"functional-programming-crash-course"},"buildId":"0lWkZSKlXROvUT9fKnbe3","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>